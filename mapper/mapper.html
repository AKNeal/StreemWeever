<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Projection Mapper</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000000;
      color: #ffffff;
      overflow: hidden;
    }

    .projection-mapper {
      width: 100vw;
      height: 100vh;
      display: flex;
      background: #0a0a0a;
    }

    .sidebar {
      width: 280px;
      background: #111111;
      border-right: 1px solid #222222;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .sidebar-section {
      padding: 20px;
      border-bottom: 1px solid #222222;
    }

    .sidebar-section h3 {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: #666666;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .btn {
      width: 100%;
      padding: 12px 16px;
      background: #1a1a1a;
      border: 1px solid #333333;
      color: #ffffff;
      cursor: pointer;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s;
      font-family: inherit;
    }

    .btn:hover {
      background: #222222;
      border-color: #00ff88;
      transform: translateX(2px);
    }

    .btn-primary {
      background: #00ff88;
      color: #000000;
      border-color: #00ff88;
      font-weight: 600;
    }

    .btn-primary:hover {
      background: #00cc6a;
      transform: translateY(-1px);
    }

    .surface-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .surface-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      background: #1a1a1a;
      border: 1px solid #333333;
      cursor: pointer;
      transition: all 0.2s;
    }

    .surface-item:hover {
      background: #222222;
      border-color: #444444;
    }

    .surface-item.selected {
      background: #001a0f;
      border-color: #00ff88;
    }

    .surface-item-name {
      flex: 1;
      font-size: 13px;
    }

    .surface-item-delete {
      padding: 6px;
      background: transparent;
      border: none;
      color: #666666;
      cursor: pointer;
      transition: color 0.2s;
    }

    .surface-item-delete:hover {
      color: #ff4444;
    }

    .main-canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .toolbar {
      height: 60px;
      background: #111111;
      border-bottom: 1px solid #222222;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 10px;
    }

    .toolbar-btn {
      padding: 10px 16px;
      background: #1a1a1a;
      border: 1px solid #333333;
      color: #ffffff;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
      font-family: inherit;
    }

    .toolbar-btn:hover {
      background: #222222;
      border-color: #00ff88;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
    }

    canvas {
      border: 1px solid #222222;
      cursor: crosshair;
    }

    .output-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      background: #000000;
    }

    .fullscreen .output-canvas {
      display: block;
    }

    .fullscreen .sidebar,
    .fullscreen .toolbar,
    .fullscreen .properties-panel {
      display: none;
    }

    .fullscreen canvas:not(.output-canvas) {
      display: none;
    }

    .properties-panel {
      width: 280px;
      background: #111111;
      border-left: 1px solid #222222;
      padding: 20px;
      overflow-y: auto;
    }

    .property {
      margin-bottom: 20px;
    }

    .property label {
      display: block;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: #666666;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .property input[type="range"] {
      width: 100%;
      height: 6px;
      background: #1a1a1a;
      border: 1px solid #333333;
      outline: none;
      -webkit-appearance: none;
    }

    .property input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #00ff88;
      cursor: pointer;
      border-radius: 50%;
    }

    .property input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #00ff88;
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }

    .property-value {
      font-size: 13px;
      color: #00ff88;
      margin-top: 4px;
    }

    input[type="file"] {
      display: none;
    }

    video {
      display: none;
    }

    .empty-state {
      text-align: center;
      color: #666666;
      font-size: 13px;
      padding: 20px;
    }

    .icon {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div class="projection-mapper" id="app">
    <div class="sidebar">
      <div class="sidebar-section">
        <h3>Media</h3>
        <input id="media-upload" type="file" accept="video/*,image/*">
        <button class="btn" onclick="app.uploadMedia()">
          <span class="icon">üìÅ</span>
          Upload Media
        </button>
        <div id="media-status" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
      </div>

      <div class="sidebar-section">
        <h3>Surfaces</h3>
        <button class="btn btn-primary" onclick="app.addSurface()">
          <span class="icon">‚ûï</span>
          Add Surface
        </button>
        
        <div class="surface-list" id="surface-list" style="margin-top: 15px;">
          <div class="empty-state">No surfaces yet</div>
        </div>
      </div>
    </div>

    <div class="main-canvas-area" id="main-area">
      <div class="toolbar">
        <button class="toolbar-btn" onclick="app.saveProject()">
          <span class="icon">üíæ</span>
          Save Project
        </button>
        <input id="load-project" type="file" accept=".json" style="display: none;">
        <button class="toolbar-btn" onclick="document.getElementById('load-project').click()">
          <span class="icon">üìÇ</span>
          Load Project
        </button>
        <div style="flex: 1;"></div>
        <button class="toolbar-btn" onclick="app.toggleFullscreen()">
          <span class="icon">‚õ∂</span>
          Output Mode
        </button>
      </div>

      <div class="canvas-container">
        <canvas id="main-canvas" width="1280" height="720"></canvas>
        <canvas id="output-canvas" class="output-canvas" width="1920" height="1080"></canvas>
      </div>
    </div>

    <div class="properties-panel">
      <h3 style="font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px; color: #666666; margin-bottom: 20px;">
        Properties
      </h3>
      
      <div id="properties-content">
        <div class="empty-state">
          Select a surface to edit properties
        </div>
      </div>
    </div>

    <video id="video-element" style="display: none;" autoplay loop muted></video>
  </div>

  <script>
    const app = {
      surfaces: [],
      selectedSurface: null,
      mediaSource: null,
      mediaType: null,
      isDragging: false,
      dragPoint: null,
      isFullscreen: false,
      mediaElement: null,

      init() {
        this.canvas = document.getElementById('main-canvas');
        this.outputCanvas = document.getElementById('output-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.outputCtx = this.outputCanvas.getContext('2d');
        this.videoElement = document.getElementById('video-element');

        // Event listeners
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
        this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
        
        document.getElementById('media-upload').addEventListener('change', (e) => this.handleMediaUpload(e));
        document.getElementById('load-project').addEventListener('change', (e) => this.loadProject(e));

        // Start render loop
        this.render();
      },

      uploadMedia() {
        document.getElementById('media-upload').click();
      },

      handleMediaUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const url = URL.createObjectURL(file);
        this.mediaType = file.type.startsWith('video/') ? 'video' : 'image';
        this.mediaSource = url;

        if (this.mediaType === 'video') {
          this.videoElement.src = url;
          this.mediaElement = this.videoElement;
        } else {
          this.mediaElement = new Image();
          this.mediaElement.src = url;
        }

        document.getElementById('media-status').textContent = 
          this.mediaType === 'video' ? 'Video loaded' : 'Image loaded';
      },

      addSurface() {
        const newSurface = {
          id: Date.now(),
          name: `Surface ${this.surfaces.length + 1}`,
          corners: [
            { x: 100, y: 100 },
            { x: 400, y: 100 },
            { x: 400, y: 400 },
            { x: 100, y: 400 }
          ],
          opacity: 1.0,
          visible: true
        };
        this.surfaces.push(newSurface);
        this.selectedSurface = newSurface.id;
        this.updateSurfaceList();
        this.updateProperties();
      },

      deleteSurface(id) {
        this.surfaces = this.surfaces.filter(s => s.id !== id);
        if (this.selectedSurface === id) {
          this.selectedSurface = null;
        }
        this.updateSurfaceList();
        this.updateProperties();
      },

      selectSurface(id) {
        this.selectedSurface = id;
        this.updateSurfaceList();
        this.updateProperties();
      },

      updateSurfaceList() {
        const list = document.getElementById('surface-list');
        if (this.surfaces.length === 0) {
          list.innerHTML = '<div class="empty-state">No surfaces yet</div>';
          return;
        }

        list.innerHTML = this.surfaces.map(surface => `
          <div class="surface-item ${surface.id === this.selectedSurface ? 'selected' : ''}" 
               onclick="app.selectSurface(${surface.id})">
            <span class="icon">‚¨ú</span>
            <span class="surface-item-name">${surface.name}</span>
            <button class="surface-item-delete" onclick="event.stopPropagation(); app.deleteSurface(${surface.id})">
              üóëÔ∏è
            </button>
          </div>
        `).join('');
      },

      updateProperties() {
        const container = document.getElementById('properties-content');
        const surface = this.surfaces.find(s => s.id === this.selectedSurface);

        if (!surface) {
          container.innerHTML = '<div class="empty-state">Select a surface to edit properties</div>';
          return;
        }

        container.innerHTML = `
          <div class="property">
            <label>Surface Name</label>
            <input type="text" class="btn" value="${surface.name}" 
                   onchange="app.updateSurfaceName(${surface.id}, this.value)">
          </div>

          <div class="property">
            <label>Opacity</label>
            <input type="range" min="0" max="1" step="0.01" value="${surface.opacity}"
                   oninput="app.updateSurfaceOpacity(${surface.id}, this.value)">
            <div class="property-value">${Math.round(surface.opacity * 100)}%</div>
          </div>

          <div class="property">
            <label>Visibility</label>
            <button class="btn" onclick="app.toggleSurfaceVisibility(${surface.id})">
              ${surface.visible ? 'Visible' : 'Hidden'}
            </button>
          </div>
        `;
      },

      updateSurfaceName(id, name) {
        const surface = this.surfaces.find(s => s.id === id);
        if (surface) {
          surface.name = name;
          this.updateSurfaceList();
        }
      },

      updateSurfaceOpacity(id, opacity) {
        const surface = this.surfaces.find(s => s.id === id);
        if (surface) {
          surface.opacity = parseFloat(opacity);
          this.updateProperties();
        }
      },

      toggleSurfaceVisibility(id) {
        const surface = this.surfaces.find(s => s.id === id);
        if (surface) {
          surface.visible = !surface.visible;
          this.updateProperties();
        }
      },

      getCanvasCoords(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      },

      handleMouseDown(e) {
        if (!this.selectedSurface) return;
        
        const coords = this.getCanvasCoords(e);
        const surface = this.surfaces.find(s => s.id === this.selectedSurface);
        
        const cornerIndex = surface.corners.findIndex(corner => {
          const dx = corner.x - coords.x;
          const dy = corner.y - coords.y;
          return Math.sqrt(dx * dx + dy * dy) < 15;
        });

        if (cornerIndex !== -1) {
          this.isDragging = true;
          this.dragPoint = { surfaceId: this.selectedSurface, cornerIndex };
        }
      },

      handleMouseMove(e) {
        if (!this.isDragging || !this.dragPoint) return;
        
        const coords = this.getCanvasCoords(e);
        const surface = this.surfaces.find(s => s.id === this.dragPoint.surfaceId);
        
        if (surface) {
          surface.corners[this.dragPoint.cornerIndex] = coords;
        }
      },

      handleMouseUp() {
        this.isDragging = false;
        this.dragPoint = null;
      },

      saveProject() {
        const project = {
          surfaces: this.surfaces,
          mediaSource: this.mediaSource,
          mediaType: this.mediaType
        };
        const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'projection-map.json';
        a.click();
      },

      loadProject(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
          const project = JSON.parse(event.target.result);
          this.surfaces = project.surfaces || [];
          this.mediaSource = project.mediaSource;
          this.mediaType = project.mediaType;
          
          if (this.mediaType === 'video') {
            this.videoElement.src = this.mediaSource;
            this.mediaElement = this.videoElement;
          } else if (this.mediaType === 'image') {
            this.mediaElement = new Image();
            this.mediaElement.src = this.mediaSource;
          }
          
          this.updateSurfaceList();
          this.updateProperties();
        };
        reader.readAsText(file);
      },

      toggleFullscreen() {
        const mainArea = document.getElementById('main-area');
        if (!this.isFullscreen) {
          mainArea.classList.add('fullscreen');
          document.documentElement.requestFullscreen?.();
        } else {
          mainArea.classList.remove('fullscreen');
          document.exitFullscreen?.();
        }
        this.isFullscreen = !this.isFullscreen;
      },

      render() {
        // Clear canvases
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.outputCtx.fillStyle = '#000000';
        this.outputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);

        // Draw grid
        this.ctx.strokeStyle = '#1a1a1a';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < this.canvas.width; i += 50) {
          this.ctx.beginPath();
          this.ctx.moveTo(i, 0);
          this.ctx.lineTo(i, this.canvas.height);
          this.ctx.stroke();
        }
        for (let i = 0; i < this.canvas.height; i += 50) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, i);
          this.ctx.lineTo(this.canvas.width, i);
          this.ctx.stroke();
        }

        // Draw surfaces
        this.surfaces.forEach(surface => {
          if (!surface.visible) return;

          [this.ctx, this.outputCtx].forEach(context => {
            context.save();
            
            // Create clipping path
            context.beginPath();
            context.moveTo(surface.corners[0].x, surface.corners[0].y);
            surface.corners.forEach(corner => {
              context.lineTo(corner.x, corner.y);
            });
            context.closePath();
            context.clip();

            // Draw media
            if (this.mediaElement && (this.mediaElement.complete !== false || this.mediaElement.readyState >= 2)) {
              context.globalAlpha = surface.opacity;
              
              const minX = Math.min(...surface.corners.map(c => c.x));
              const minY = Math.min(...surface.corners.map(c => c.y));
              const maxX = Math.max(...surface.corners.map(c => c.x));
              const maxY = Math.max(...surface.corners.map(c => c.y));
              
              context.drawImage(this.mediaElement, minX, minY, maxX - minX, maxY - minY);
            }
            
            context.restore();

            // Draw outline (main canvas only)
            if (context === this.ctx) {
              context.strokeStyle = surface.id === this.selectedSurface ? '#00ff88' : '#333333';
              context.lineWidth = 2;
              context.beginPath();
              context.moveTo(surface.corners[0].x, surface.corners[0].y);
              surface.corners.forEach(corner => {
                context.lineTo(corner.x, corner.y);
              });
              context.closePath();
              context.stroke();

              // Draw corner pins
              surface.corners.forEach((corner) => {
                context.fillStyle = surface.id === this.selectedSurface ? '#00ff88' : '#666666';
                context.beginPath();
                context.arc(corner.x, corner.y, 8, 0, Math.PI * 2);
                context.fill();
                
                context.strokeStyle = '#000000';
                context.lineWidth = 2;
                context.stroke();
              });
            }
          });
        });

        requestAnimationFrame(() => this.render());
      }
    };

    // Initialize on page load
    window.addEventListener('load', () => app.init());
  </script>
</body>
</html>
